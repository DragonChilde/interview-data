# JVM垃圾回收机制、GC发生在JVM哪部分，有几种GC，他们的算法是什么

> GC发生在JVM哪部分

GC是发生在堆内

> GC是什么？有几种GC？

GC是分代收集算法，在堆内不同的区域有不同的策略

两种GC：**Minor GC** , **Full GC**

- 次数上频繁收集Young区　**Minor GC**
- 次数上较少收集Old区　**Full GC**
- 基本不动perm区(永久区）

> 它们的算法是什么？

GC4大算法：

- **引用计数法**

  只要有对象被引用，GC就不进行回收，**这种方式已被淘汰(JVM的实现一般不采用这种方式)**

  缺点：

  1. 每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗；
  2. 较难处理循环引用【A引用B，B引用A】

- **复制算法**（copying）

  年轻代中使用的是`Minor GC`，这种GC算法采用的是复制算法（copying）：

  - 原理

    ![](http://120.77.237.175:9080/photos/eight/java/jvm/03.png)

  - 复制算法原理

    Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，也即一旦收集后，Eden是就变成空的了。

    当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。

  - 算法分析

    年轻代中的GC,主要是复制算法（Copying）

    HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

  ![](http://120.77.237.175:9080/photos/eight/java/jvm/01.png)

  - JVM之复制

    在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

    ![](http://120.77.237.175:9080/photos/eight/java/jvm/04.png)

  - 复制算法

    因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。

    ![](http://120.77.237.175:9080/photos/eight/java/jvm/05.gif)

  - 劣势

    复制算法它的缺点也是相当明显的。

    1. 它浪费了一半的内存，这太要命了。
    2. 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。

- **标记算法（Mark-Sweep）**

  **老年代一般是由标记清除或者是标记清除与标记整理的混合实现**

  - 原理

    ![](http://120.77.237.175:9080/photos/eight/java/jvm/02.png)

  - 标记清除

    当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。

    - 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象   标记为存活的对象。
    - 清除：遍历整个堆，把未标记的对象清除。
    - 缺点：此算法需要暂停整个应用，会产生内存碎片

    用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行

    ![](http://120.77.237.175:9080/photos/eight/java/jvm/06.gif)

  - 劣势

    - 首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲
  - 其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。

- **标记压缩（Mark-Compact）**

  **老年代一般是由标记清除或者是标记清除与标记整理的混合实现**

  - 原理

    ![](http://120.77.237.175:9080/photos/eight/java/jvm/07.png)

    在整理压缩阶段，不再对标记的对象做回收，而是通过所有存话对象都向一端移动，然后直接清除边界以外的内存。
  
    可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销
  
    标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价
  
    - 标记（Mark）：与标记清除一样。
    - 压缩（Compact）：再次扫描并往一端滑动存活对象（在整理压缩阶段，不在对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存）
    - 优点：没有内存碎片
    - 缺点：需要移动对象的成本
  
  - 劣势
    - 标记/整理算法唯一的缺点就是效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址
    - 从效率上来说，标记/整理算法要低于复制算法
  

- 老年代Full GC有两种算法结合使用：**标记-清除-压缩（Mark-Sweep-Compact）**

  - 原理：

    1. Mark-Sweep和Mark-Compact结合
    2. 和Mark-Sweep一致，当进行多次GC后才Compact

  - Full GC两种算法结合使用，先标记进行清除，清除多次并产生很多内存碎片之后，再做压缩

    优点：减少移动对象成本

